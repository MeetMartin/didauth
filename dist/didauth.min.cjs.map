{"version":3,"file":"didauth.min.cjs","mappings":"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","sources":["webpack://didauth/webpack/bootstrap","webpack://didauth/webpack/runtime/define property getters","webpack://didauth/webpack/runtime/hasOwnProperty shorthand","webpack://didauth/webpack/runtime/make namespace object","webpack://didauth/./node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack://didauth/external commonjs2 \"@7urtle/lambda\"","webpack://didauth/./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","webpack://didauth/external commonjs2 \"axios\"","webpack://didauth/external commonjs2 \"uuid\"","webpack://didauth/./src/effects/Presentation.js","webpack://didauth/./src/utils.js","webpack://didauth/./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","webpack://didauth/./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","webpack://didauth/./node_modules/@babel/runtime/helpers/esm/iterableToArray.js","webpack://didauth/./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","webpack://didauth/./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","webpack://didauth/./src/effects/DID.js","webpack://didauth/./src/effects/AccessToken.js","webpack://didauth/./src/authentication.js","webpack://didauth/./src/effects/Messaging.js","webpack://didauth/./src/pushAuthentication.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@7urtle/lambda\");","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"axios\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"uuid\");","// @ts-check\r\n\r\nimport { isNothing, AsyncEffect } from '@7urtle/lambda';\r\nimport axios from 'axios';\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\nimport { formatError } from '../utils.js';\r\n\r\n/**\r\n * @typedef {object} CreatePresentationTemplatePayload\r\n * @property {string} tenant MATTR tenant\r\n * @property {string} accessToken MATTR platform access token string\r\n * @property {string} [name] convenience attribute for quickly determining the intended purpose of a created template\r\n * @property {string} [domain] the domain of the tenant being used\r\n * @property {[object]} [query] type of presentation: DIDAuth, QueryByExample, QueryByFrame\r\n */\r\n\r\n/**\r\n * createPresentationTemplate creates a Presentation Request Template that defines which credentials are required for presentation.\r\n * This is used to create the actual Presentation Request, which is used by the Mobile Wallet to select which credential it should\r\n * display to the Holder, asking for confirmation to be used in the Presentation to be sent.\r\n * \r\n * The domain value must always match the domain of the tenant being used. In MATTR Platform you may customize your domain\r\n * to represent you when you request is displayed in the Mobile Wallet app.\r\n * \r\n * Uses MATTR platform /v1/presentations/templates.\r\n * \r\n * @pure\r\n * @HindleyMilner createPresentationTemplate :: CreatePresentationTemplatePayload -> AsyncEffect\r\n * @param {CreatePresentationTemplatePayload} payload \r\n * @returns {AsyncEffect}\r\n */\r\nconst createPresentationTemplate = payload =>\r\n    AsyncEffect\r\n    .of(reject => resolve =>\r\n        (isNothing(payload) && reject('createPresentationTemplate payload is Nothing.')) ||\r\n        (isNothing(payload.tenant) && reject('createPresentationTemplate payload.tenant is Nothing.')) ||\r\n        (isNothing(payload.accessToken) && reject('createPresentationTemplate payload.accessToken is Nothing.')) ||\r\n        axios.post(\r\n            `https://${payload.tenant}/v1/presentations/templates`,\r\n            {\r\n                \"name\": payload.name || uuidv4(),\r\n                \"domain\": payload.domain || payload.tenant,\r\n                \"query\": payload.query || [\r\n                    {\r\n                        \"type\": \"DIDAuth\"\r\n                    }\r\n                ]\r\n            },\r\n            {\r\n                headers: {\r\n                    \"Accept\": \"application/json\",\r\n                    \"Content-Type\": \"application/json\",\r\n                    \"Authorization\": `Bearer ${payload.accessToken}`\r\n                }\r\n            }\r\n        )\r\n        .then(resolve)\r\n        .catch(error => reject(`Creating Presentation Template: ${formatError(error)}`))\r\n    );\r\n\r\n/**\r\n * @typedef {object} CreatePresentationRequestPayload\r\n * @property {string} tenant MATTR tenant\r\n * @property {string} accessToken MATTR platform access token string\r\n * @property {string} challengeId Challenge ID used by your app to tie together the request and the callback response\r\n * @property {string} did verifier DID\r\n * @property {string} templateId presentation template ID\r\n * @property {string} callbackURL callback URL that MATTR platform will call with the request result\r\n * @property {number} [expiresTime] Unix timestamp in ms after which the request will be expired, 5 minutes default\r\n */\r\n\r\n/**\r\n * createPresentationRequest creates a short lived Presentation Request.\r\n * \r\n * Uses MATTR platform /v1/presentations/requests.\r\n * \r\n * @pure\r\n * @HindleyMilner createPresentationRequest :: CreatePresentationRequestPayload -> AsyncEffect\r\n * @param {CreatePresentationRequestPayload} payload \r\n * @returns {AsyncEffect}\r\n */\r\nconst createPresentationRequest = payload =>\r\n    AsyncEffect\r\n    .of(reject => resolve =>\r\n        (isNothing(payload) && reject('createPresentationRequest payload is Nothing.')) ||\r\n        (isNothing(payload.tenant) && reject('createPresentationRequest payload.tenant is Nothing.')) ||\r\n        (isNothing(payload.accessToken) && reject('createPresentationRequest payload.accessToken is Nothing.')) ||\r\n        (isNothing(payload.challengeId) && reject('createPresentationRequest payload.challengeId is Nothing.')) ||\r\n        (isNothing(payload.did) && reject('createPresentationRequest payload.did is Nothing.')) ||\r\n        (isNothing(payload.templateId) && reject('createPresentationRequest payload.templateId is Nothing.')) ||\r\n        (isNothing(payload.callbackURL) && reject('createPresentationRequest payload.callbackURL is Nothing.')) ||\r\n        axios.post(\r\n            `https://${payload.tenant}/v1/presentations/requests`,\r\n            {\r\n                \"challenge\": payload.challengeId,\r\n                \"did\": payload.did,\r\n                \"templateId\": payload.templateId,\r\n                \"expiresTime\": payload.expiresTime || Math.round((new Date()).getTime()) + 300000,\r\n                \"callbackUrl\": payload.callbackURL\r\n            },\r\n            {\r\n                headers: {\r\n                    \"Accept\": \"application/json\",\r\n                    \"Content-Type\": \"application/json\",\r\n                    \"Authorization\": `Bearer ${payload.accessToken}`\r\n                }\r\n            }\r\n        )\r\n        .then(resolve)\r\n        .catch(error => reject(`Creating Presentation Request: ${formatError(error)}`))\r\n    );\r\n\r\nexport {\r\n    createPresentationTemplate,\r\n    createPresentationRequest\r\n};","// @ts-check\r\n\r\nimport { deepInspect, isNothing, isNotString, Failure, Success, Either, compose, map, mergeEithers, AsyncEffect, mergeAsyncEffects } from '@7urtle/lambda';\r\n\r\nimport { createPresentationRequest } from './effects/Presentation.js';\r\nimport { readDID } from './effects/DID.js';\r\n\r\n/**\r\n* @typedef {object} MATTRError\r\n* @property {{data: {message: string, details: string}}} response\r\n*/\r\n\r\n/**\r\n * formatError tkaes MATTRError returned by the MATTR platform and formats it\r\n * into an error string.\r\n * \r\n * @pure\r\n * @HindleyMilner formatError :: MATTRError -> string\r\n * @param {MATTRError} error \r\n * @returns {string}\r\n */\r\nconst formatError = error =>\r\n    `${error}.` +\r\n    `${error && error.response && error.response.data && error.response.data.message ? ` ${error.response.data.message}.` : ''}` +\r\n    `${error && error.response && error.response.data && error.response.data.details ? ` ${deepInspect(error.response.data.details)}.` : ''}`;\r\n\r\n/**\r\n * validatePayloadKey validates that key withing a payload is a string that is not Nothing.\r\n * \r\n * On success it returns Success with the original payload.\r\n * \r\n * On failure it returns Failure with an error message.\r\n * \r\n * @pure\r\n * @HindleyMilner validatePayloadKey :: object -> string -> Either\r\n * @param {object} payload \r\n * @returns {function(string): Either}\r\n * @example\r\n * validatePayloadKey({key: 'string'})('key');\r\n * // => Success({key: 'string'})\r\n * \r\n * validatePayloadKey({key: 'string'})('fake');\r\n * // => Failure('payload.fake is Nothing or not a string')\r\n */\r\nconst validatePayloadKey = payload => key =>\r\n    isNothing(payload[key]) || isNotString(payload[key])\r\n    ? Failure(`payload.${key} is Nothing or not a string.`)\r\n    : Success(payload);\r\n\r\n/**\r\n * validatePayload validates payload required keys to ensure their values are strings that are not Nothing. It returns\r\n * a Failure with an array of validation error messages or a Success with the original payload.\r\n * \r\n * @pure\r\n * @HindleyMilner validatePayload :: Array.<string> -> object -> Either\r\n * @param {Array.<string>} keys\r\n * @returns {function(object): Either} \r\n */\r\n const validatePayload = keys => payload => \r\n    compose(\r\n        map(values => values[0]),\r\n        validate => mergeEithers(\r\n            ...map(key => validate(key))(keys)\r\n        )\r\n    )\r\n    (validatePayloadKey(payload));\r\n\r\n/**\r\n * @typedef {object} PresentationRequestAndDIDPayload\r\n * @property {string} tenant Your MATTR tenant\r\n * @property {string} accessToken MATTR platform access token string\r\n * @property {string} did Verifier DID representing your application\r\n * @property {string} challengeId Challenge ID used by your app to tie together the request and the callback response\r\n * @property {string} templateId Authentication presentation template ID\r\n * @property {string} callbackURL Callback URL that MATTR platform will call with the request result\r\n */\r\n\r\n/**\r\n * getPresentationRequestAndDID creates merged AsyncEffect that can create a presentation request\r\n * and read DID in parallel.\r\n * \r\n * @pure\r\n * @HindleyMilner getPresentationRequestAndDID :: FullPushAuthenticationPayload -> AsyncEffect\r\n * @param {PresentationRequestAndDIDPayload} payload \r\n * @returns {AsyncEffect}\r\n */\r\n const getPresentationRequestAndDID = payload =>\r\n    mergeAsyncEffects(\r\n        createPresentationRequest(payload),\r\n        readDID(payload)\r\n    );\r\n\r\nexport {\r\n    formatError,\r\n    validatePayloadKey,\r\n    validatePayload,\r\n    getPresentationRequestAndDID\r\n};\r\n","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","// @ts-check\r\n\r\nimport { isNothing, AsyncEffect } from '@7urtle/lambda';\r\nimport axios from 'axios';\r\n\r\nimport { formatError } from '../utils.js';\r\n\r\n/**\r\n * @typedef {object} CreateDIDPayload\r\n * @property {string} tenant MATTR tenant\r\n * @property {string} accessToken MATTR platform access token string\r\n * @property {string} [method] DID method: key, web, ion\r\n * @property {object} [options] Options for the given DID method\r\n */\r\n\r\n/**\r\n * createDID takes a supported DID Method (default key) and generates keys and associated information\r\n * for a new DID and registers the DID Document if applicable.\r\n * \r\n * Uses /v1/dids.\r\n * \r\n * @pure\r\n * @HindleyMilner createDID :: CreateDIDPayload -> AsyncEffect\r\n * @param {CreateDIDPayload} payload\r\n * @returns {AsyncEffect}\r\n */\r\nconst createDID = payload =>\r\n    AsyncEffect\r\n    .of(reject => resolve =>\r\n        (isNothing(payload) && reject('createDID payload is Nothing.')) ||\r\n        (isNothing(payload.tenant) && reject('createDID payload.tenant is Nothing.')) ||\r\n        (isNothing(payload.accessToken) && reject('createDID payload.accessToken is Nothing.')) ||\r\n        axios.post(\r\n            `https://${payload.tenant}/v1/dids`,\r\n            {\r\n                \"method\": payload.method || \"key\",\r\n                \"options\": payload.options || {}\r\n            },\r\n            {\r\n                headers: {\r\n                    \"Accept\": \"application/json\",\r\n                    \"Content-Type\": \"application/json\",\r\n                    \"Authorization\": `Bearer ${payload.accessToken}`\r\n                }\r\n            }\r\n        )\r\n        .then(resolve)\r\n        .catch(error => reject(`Creating DID: ${formatError(error)}`))\r\n    );\r\n\r\n/**\r\n * @typedef {object} ReadDIDPayload\r\n * @property {string} tenant MATTR tenant\r\n * @property {string} accessToken MATTR platform access token string\r\n * @property {string} did Decentralized Identifier under W3C standard\r\n */\r\n\r\n/**\r\n * readDID resolves a DID. When the DID is retrieved by the DID provided in the request, the DID Document is also attempted\r\n * to be resolved by using the DID method and method identifier.\r\n * \r\n * Uses /v1/dids/{did}.\r\n * \r\n * @pure\r\n * @HindleyMilner readDID :: ReadDIDPayload -> AsyncEffect\r\n * @param {ReadDIDPayload} payload\r\n * @returns {AsyncEffect}\r\n */\r\nconst readDID = payload =>\r\n    AsyncEffect\r\n    .of(reject => resolve =>\r\n        (isNothing(payload) && reject('readDID payload is Nothing.')) ||\r\n        (isNothing(payload.tenant) && reject('readDID payload.tenant is Nothing.')) ||\r\n        (isNothing(payload.did) && reject('readDID payload.did is Nothing.')) ||\r\n        (isNothing(payload.accessToken) && reject('readDID payload.accessToken is Nothing.')) ||\r\n        axios.get(\r\n            `https://${payload.tenant}/v1/dids/${payload.did}`,\r\n            {\r\n                headers: {\r\n                    \"Accept\": \"application/json\",\r\n                    \"Content-Type\": \"application/json\",\r\n                    \"Authorization\": `Bearer ${payload.accessToken}`\r\n                }\r\n            }\r\n        )\r\n        .then(resolve)\r\n        .catch(error => reject(`Reading DID: ${formatError(error)}`))\r\n    );\r\n\r\nexport {\r\n    createDID,\r\n    readDID\r\n};","// @ts-check\r\n\r\nimport { isNothing, AsyncEffect } from '@7urtle/lambda';\r\nimport axios from 'axios';\r\n\r\nimport { formatError } from '../utils.js';\r\n\r\n/**\r\n * @typedef {object} RequestAccessTokenPayload\r\n * @property {string} clientId ID provided as part of MATTR platform onboarding\r\n * @property {string} clientSecret Secret provided as part of MATTR platform onboarding\r\n */\r\n\r\n/**\r\n * requestAccessToken calls a MATTR uthorization endpoint for gaining token used for API requests requiring bearerAuth.\r\n * \r\n * Uses https://auth.mattr.global/oauth/token.\r\n * \r\n * @pure\r\n * @HindleyMilner requestAccessToken :: RequestAccessTokenPayload -> AsyncEffect\r\n * @param {RequestAccessTokenPayload} payload\r\n * @returns {AsyncEffect}\r\n */\r\nconst requestAccessToken = payload =>\r\n    AsyncEffect\r\n    .of(reject => resolve =>\r\n        (isNothing(payload) && reject('requestAccessToken payload is Nothing.')) ||\r\n        (isNothing(payload.clientId) && reject('requestAccessToken payload.clientId is Nothing.')) ||\r\n        (isNothing(payload.clientSecret) && reject('requestAccessToken payload.clientSecret is Nothing.')) ||\r\n        axios\r\n        .post(\r\n            'https://auth.mattr.global/oauth/token',\r\n            {\r\n                \"client_id\": payload.clientId,\r\n                \"client_secret\": payload.clientSecret,\r\n                \"audience\": \"https://vii.mattr.global\",\r\n                \"grant_type\": \"client_credentials\"\r\n            }\r\n        )\r\n        .then(resolve)\r\n        .catch(error => reject(`Requesting MATTR Acccess Token: ${formatError(error)}`))\r\n    );\r\n    \r\nexport {\r\n    requestAccessToken\r\n};","// @ts-check\r\n\r\nimport { map, flatMap, compose, eitherToAsyncEffect, AsyncEffect } from '@7urtle/lambda';\r\n\r\nimport { validatePayload, getPresentationRequestAndDID } from './utils.js';\r\nimport { requestAccessToken } from './effects/AccessToken.js';\r\nimport { createJWS } from './effects/Messaging.js';\r\n\r\n/**\r\n * @typedef {object} AuthenticationPayload\r\n * @property {string} clientId ID provided as part of MATTR platform onboarding\r\n * @property {string} clientSecret Secret provided as part of MATTR platform onboarding\r\n * @property {string} tenant Your MATTR tenant\r\n * @property {string} did Verifier DID representing your application\r\n * @property {string} challengeId Challenge ID used by your app to tie together the request and the callback response\r\n * @property {string} templateId Authentication presentation template ID\r\n * @property {string} callbackURL Callback URL that MATTR platform will call with the request result\r\n */\r\n\r\n/**\r\n * @typedef {object} FullAuthenticationPayload\r\n * @property {string} tenant Your MATTR tenant\r\n * @property {string} accessToken MATTR platform access token string\r\n * @property {string} did Verifier DID representing your application\r\n * @property {string} challengeId Challenge ID used by your app to tie together the request and the callback response\r\n * @property {string} templateId Authentication presentation template ID\r\n * @property {string} callbackURL Callback URL that MATTR platform will call with the request result\r\n */\r\n\r\n/**\r\n * getJWSURL creates JWS url from JWS\r\n * \r\n * @pure\r\n * @HindleyMilner getJWSURL :: {tenant: string, jws: string} -> string\r\n * @param {{tenant: string, jws: string}} payload \r\n * @returns {string}\r\n */\r\nconst getJWSURL = payload => `https://${payload.tenant}/?request=${payload.jws}`;\r\n\r\n/**\r\n * getJWS creates a JWS URL by signing authentication presentation request for a verifier DID.\r\n * \r\n * @pure\r\n * @HindleyMilner getJWSURL :: FullAuthenticationPayload -> AsyncEffect\r\n * @param {FullAuthenticationPayload} payload \r\n * @returns {AsyncEffect}\r\n */\r\nconst getJWS = payload =>\r\n    compose(\r\n        map(jws => getJWSURL({tenant: payload.tenant, jws: jws})),\r\n        map(result => result.data),\r\n        flatMap(data => createJWS({...payload, ...data})),\r\n        map(responses => ({request: responses[0].data.request, didUrl: responses[1].data.didDocument.authentication[0]})),\r\n        getPresentationRequestAndDID\r\n    )(payload);\r\n\r\n/**\r\n * authentication creates an authentication request URL for DID Authentication with your MATTR tenant. The resulting\r\n * URL is intended to be used to redirect the user.\r\n * \r\n * As a result, MATTR platform calls supplied callback URL with the result that connects to your request by a supplied\r\n * Challenge ID.\r\n * \r\n * We return a monad @7urtle/lambda.AsyncEffect as the output of the function: https://www.7urtle.com/documentation-7urtle-lambda#lambda-AsyncEffect.\r\n * On success the monad will hold a string with a redirect URL with JWS intended for the digital wallet. On failure it with hold a string\r\n * describing the error.\r\n * \r\n * @pure\r\n * @HindleyMilner authentication :: AuthenticationPayload -> AsyncEffect\r\n * @param {AuthenticationPayload} payload \r\n * @returns {AsyncEffect}\r\n * @example\r\n * import { authentication } from 'didauth';\r\n * \r\n * const payload = {\r\n *     clientId: 'client id', // client id provided by MATTR\r\n *     clientSecret: 'client secret', // client secret provided by MATTR\r\n *     tenant: 'your-tenant.vii.mattr.global', // your tenant provided by MATTR\r\n *     did: 'did:method:code', // your verifier DID representing your application created in MATTR platform\r\n *     challengeId: 'your-challenge-id', // custom ID provided by your application to connect request internally\r\n *     templateId: 'presentation template id', // presentation template ID created in MATTR platform\r\n *     callbackURL: 'https://your-domain.tld/didauth/callback' // callback url of your website that the digital wallet will call\r\n * };\r\n * \r\n * authentication(payload)\r\n * .trigger\r\n * (errors => console.log(errors) || ({\r\n *     statusCode: 500,\r\n *     body: 'Internal Server Error'\r\n * }))\r\n * (JWSURL => ({\r\n *     statusCode: 301,\r\n *     headers: {\r\n *         locations: JWSURL\r\n *     }\r\n * }));\r\n */\r\nconst authentication = payload =>\r\n    compose(\r\n        flatMap(accessToken => getJWS({\r\n            ...payload,\r\n            accessToken: accessToken\r\n        })),\r\n        map(response => response.data.access_token),\r\n        flatMap(requestAccessToken),\r\n        eitherToAsyncEffect,\r\n        validatePayload(['clientId', 'clientSecret', 'tenant', 'did', 'challengeId', 'templateId', 'callbackURL'])\r\n    )(payload);\r\n\r\nexport {\r\n    authentication,\r\n    getJWS,\r\n    getJWSURL\r\n};","// @ts-check\r\n\r\nimport { isNothing, AsyncEffect } from '@7urtle/lambda';\r\nimport axios from 'axios';\r\n\r\nimport { formatError } from '../utils.js';\r\n\r\n/**\r\n * @typedef {object} CreateJWSPayload\r\n * @property {string} tenant MATTR tenant\r\n * @property {string} accessToken MATTR platform access token string\r\n * @property {string} didUrl authentication key value from DID document\r\n * @property {object} request message to be signed\r\n */\r\n\r\n/**\r\n * createJWS creates a signed message in the form of a JWS (JSON Web Signature) using the specific\r\n * Key from the DID (Decentralized Identifier) supplied in the request.\r\n * \r\n * Uses MATTR platform /v1/messaging/sign.\r\n * \r\n * @pure\r\n * @HindleyMilner createJWS :: CreateJWSPayload -> AsyncEffect\r\n * @param {CreateJWSPayload} payload \r\n * @returns {AsyncEffect}\r\n */\r\nconst createJWS = payload =>\r\n    AsyncEffect\r\n    .of(reject => resolve =>\r\n        (isNothing(payload) && reject('createJWS payload is Nothing.')) ||\r\n        (isNothing(payload.tenant) && reject('createJWS payload.tenant is Nothing.')) ||\r\n        (isNothing(payload.accessToken) && reject('createJWS payload.accessToken is Nothing.')) ||\r\n        (isNothing(payload.didUrl) && reject('createJWS payload.didUrl is Nothing.')) ||\r\n        (isNothing(payload.request) && reject('createJWS payload.request is Nothing.')) ||\r\n        axios.post(\r\n            `https://${payload.tenant}/v1/messaging/sign`,\r\n            {\r\n                \"didUrl\": payload.didUrl,\r\n                \"payload\": payload.request\r\n            },\r\n            {\r\n                headers: {\r\n                    \"Accept\": \"application/json\",\r\n                    \"Content-Type\": \"application/json\",\r\n                    \"Authorization\": `Bearer ${payload.accessToken}`\r\n                }\r\n            }\r\n        )\r\n        .then(resolve)\r\n        .catch(error => reject(`Creating JWS: ${formatError(error)}`))\r\n    );\r\n\r\n/**\r\n * @typedef {object} CreateJWEPayload\r\n * @property {string} tenant MATTR tenant\r\n * @property {string} accessToken MATTR platform access token string\r\n * @property {string} didUrl authentication key value from DID document\r\n * @property {[string]} recipientDids array of recipient DID strings\r\n * @property {object} request message to be signed\r\n */\r\n\r\n/**\r\n * createJWE encrypts a payload using a JWM format.\r\n * \r\n * Uses MATTR platform /v1/messaging/encrypt.\r\n * \r\n * @pure\r\n * @HindleyMilner createJWE :: CreateJWEPayload -> AsyncEffect\r\n * @param {CreateJWEPayload} payload \r\n * @returns {AsyncEffect}\r\n */\r\nconst createJWE = payload =>\r\n    AsyncEffect\r\n    .of(reject => resolve =>\r\n        (isNothing(payload) && reject('createJWE payload is Nothing.')) ||\r\n        (isNothing(payload.tenant) && reject('createJWE payload.tenant is Nothing.')) ||\r\n        (isNothing(payload.accessToken) && reject('createJWE payload.accessToken is Nothing.')) ||\r\n        (isNothing(payload.didUrl) && reject('createJWE payload.didUrl is Nothing.')) ||\r\n        (isNothing(payload.recipientDids) && reject('createJWE payload.recipientDids is Nothing.')) ||\r\n        (isNothing(payload.request) && reject('createJWE payload.request is Nothing.')) ||\r\n        axios.post(\r\n            `https://${payload.tenant}/v1/messaging/encrypt`,\r\n            {\r\n                \"senderDidUrl\": payload.didUrl,\r\n                \"recipientDidUrls\": payload.recipientDids,\r\n                \"payload\": payload.request\r\n            },\r\n            {\r\n                headers: {\r\n                    \"Accept\": \"application/json\",\r\n                    \"Content-Type\": \"application/json\",\r\n                    \"Authorization\": `Bearer ${payload.accessToken}`\r\n                }\r\n            }\r\n        )\r\n        .then(resolve)\r\n        .catch(error => reject(`Creating JWE: ${formatError(error)}`))\r\n    );\r\n\r\n/**\r\n * @typedef {object} SendMessagePayload\r\n * @property {string} tenant MATTR tenant\r\n * @property {string} accessToken MATTR platform access token string\r\n * @property {string} recipientDid message recipient DID\r\n * @property {object} message JWE message to be sent\r\n */\r\n\r\n/**\r\n * sendMessage sends an encrypted JWM format DIDComm message to a DID service endpoint.\r\n * \r\n * Uses MATTR platform /v1/messaging/send.\r\n * \r\n * @pure\r\n * @HindleyMilner sendMessage :: SendMessagePayload -> AsyncEffect\r\n * @param {SendMessagePayload} payload \r\n * @returns {AsyncEffect}\r\n */\r\nconst sendMessage = payload =>\r\n    AsyncEffect\r\n    .of(reject => resolve =>\r\n        (isNothing(payload) && reject('sendMessage payload is Nothing.')) ||\r\n        (isNothing(payload.tenant) && reject('sendMessage payload.tenant is Nothing.')) ||\r\n        (isNothing(payload.accessToken) && reject('sendMessage payload.accessToken is Nothing.')) ||\r\n        (isNothing(payload.recipientDid) && reject('sendMessage payload.recipientDid is Nothing.')) ||\r\n        (isNothing(payload.message) && reject('sendMessage payload.message is Nothing.')) ||\r\n        axios.post(\r\n            `https://${payload.tenant}/v1/messaging/send`,\r\n            {\r\n                \"to\": payload.recipientDid,\r\n                \"message\": payload.message\r\n            },\r\n            {\r\n                headers: {\r\n                    \"Accept\": \"application/json\",\r\n                    \"Content-Type\": \"application/json\",\r\n                    \"Authorization\": `Bearer ${payload.accessToken}`\r\n                }\r\n            }\r\n        )\r\n        .then(resolve)\r\n        .catch(error => reject(`Sending Message: ${formatError(error)}`))\r\n    );\r\n\r\nexport {\r\n    createJWE,\r\n    createJWS,\r\n    sendMessage\r\n};","// @ts-check\r\n\r\nimport { map, flatMap, compose, eitherToAsyncEffect, AsyncEffect } from '@7urtle/lambda';\r\n\r\nimport { validatePayload, getPresentationRequestAndDID } from './utils.js';\r\nimport { requestAccessToken } from './effects/AccessToken.js';\r\nimport { createJWE, sendMessage } from './effects/Messaging.js';\r\n\r\n/**\r\n * @typedef {object} PushAuthenticationPayload\r\n * @property {string} clientId ID provided as part of MATTR platform onboarding\r\n * @property {string} clientSecret Secret provided as part of MATTR platform onboarding\r\n * @property {string} tenant Your MATTR tenant\r\n * @property {string} did Verifier DID representing your application,\r\n * @property {string} recipientDid User's DID stored by your application\r\n * @property {string} challengeId Challenge ID used by your app to tie together the request and the callback response\r\n * @property {string} templateId Authentication presentation template ID\r\n * @property {string} callbackURL Callback URL that MATTR platform will call with the request result\r\n */\r\n\r\n/**\r\n * @typedef {object} FullPushAuthenticationPayload\r\n * @property {string} tenant Your MATTR tenant\r\n * @property {string} accessToken MATTR platform access token string\r\n * @property {string} did Verifier DID representing your application,\r\n * @property {string} recipientDid User's DID stored by your application\r\n * @property {string} challengeId Challenge ID used by your app to tie together the request and the callback response\r\n * @property {string} templateId Authentication presentation template ID\r\n * @property {string} callbackURL Callback URL that MATTR platform will call with the request result\r\n */\r\n\r\n/**\r\n * createPushRequest creates an authentication that is sent to a digital wallet\r\n * \r\n * @pure\r\n * @HindleyMilner createPushRequest :: FullPushAuthenticationPayload -> AsyncEffect\r\n * @param {FullPushAuthenticationPayload} payload \r\n * @returns {AsyncEffect}\r\n */\r\nconst createPushRequest = payload =>\r\n    compose(\r\n        flatMap(message => sendMessage({...payload, message: message})),\r\n        map(response => response.data.jwe),\r\n        flatMap(request => createJWE({...payload, ...request, recipientDids: [payload.recipientDid]})),\r\n        map(responses => ({request: responses[0].data.request, didUrl: responses[1].data.didDocument.keyAgreement[0].id})),\r\n        getPresentationRequestAndDID\r\n    )(payload);\r\n\r\n/**\r\n * pushAuthentication creates an authentication digital wallet push request for DID Authentication with your MATTR tenant. It uses the recipientDID\r\n * stored in your system to find the user's digital wallet and ask them for authentication through a push request on their phone.\r\n * \r\n * As a result, MATTR platform calls supplied callback URL with the result that connects to your request by a supplied\r\n * Challenge ID.\r\n * \r\n * We return a monad @7urtle/lambda.AsyncEffect as the output of the function: https://www.7urtle.com/documentation-7urtle-lambda#lambda-AsyncEffect.\r\n * On success the monad will hold the string 'Success' indicating that the authentication request was sent to a digital wallet. On failure it with hold a string\r\n * describing the error.\r\n * \r\n * @pure\r\n * @HindleyMilner pushAuthentication :: PushAuthenticationPayload -> AsyncEffect\r\n * @param {PushAuthenticationPayload} payload \r\n * @returns {AsyncEffect}\r\n * @example\r\n * import { pushAuthentication } from 'didauth';\r\n * \r\n * const payload = {\r\n *     clientId: 'client id', // client id provided by MATTR\r\n *     clientSecret: 'client secret', // client secret provided by MATTR\r\n *     tenant: 'your-tenant.vii.mattr.global', // your tenant provided by MATTR\r\n *     did: 'did:method:code', // your verifier DID representing your application created in MATTR platform\r\n *     recipientDid: 'did:method:code', // users DID store by your application\r\n *     challengeId: 'your-challenge-id', // custom ID provided by your application to connect request internally\r\n *     templateId: 'presentation template id', // presentation template ID created in MATTR platform\r\n *     callbackURL: 'https://your-domain.tld/didauth/callback' // callback url of your website that the digital wallet will call\r\n * };\r\n * \r\n * pushAuthentication(payload)\r\n * .trigger\r\n * (errors => console.log(errors) || ({\r\n *     statusCode: 500,\r\n *     body: 'Internal Server Error'\r\n * }))\r\n * (() => ({\r\n *     statusCode: 204\r\n * }));\r\n */\r\nconst pushAuthentication = payload =>\r\n    compose(\r\n        map(() => 'Success'),\r\n        flatMap(accessToken => createPushRequest({\r\n            ...payload,\r\n            accessToken: accessToken\r\n        })),\r\n        map(response => response.data.access_token),\r\n        flatMap(requestAccessToken),\r\n        eitherToAsyncEffect,\r\n        validatePayload(['clientId', 'clientSecret', 'tenant', 'did', 'recipientDid', 'challengeId', 'templateId', 'callbackURL'])\r\n    )(payload);\r\n\r\nexport {\r\n    pushAuthentication,\r\n    createPushRequest\r\n};"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","_defineProperty","configurable","writable","require","_arrayLikeToArray","arr","len","length","i","arr2","Array","formatError","error","response","data","message","details","deepInspect","validatePayload","keys","payload","compose","map","values","validate","mergeEithers","isArray","iter","iterator","from","minLen","n","toString","slice","constructor","name","test","TypeError","isNothing","isNotString","Failure","Success","validatePayloadKey","getPresentationRequestAndDID","mergeAsyncEffects","AsyncEffect","reject","resolve","tenant","accessToken","challengeId","did","templateId","callbackURL","axios","expiresTime","Math","round","Date","getTime","headers","then","createPresentationRequest","readDID","requestAccessToken","clientId","clientSecret","authentication","flatMap","jws","getJWSURL","result","didUrl","request","createJWS","responses","didDocument","getJWS","access_token","eitherToAsyncEffect","pushAuthentication","recipientDid","sendMessage","jwe","recipientDids","createJWE","keyAgreement","id","createPushRequest"],"sourceRoot":""}